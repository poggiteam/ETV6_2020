---
title: "Trajectory ETV6 patient control only analysis"
author: "Laurent H"
date: "03/2022"
always_allow_html: yes
output: 
  rmarkdown::html_document:
    code_folding: hide
    theme: cerulean
    toc: true
toc_float:
  toc_collapsed: true
pdf_document:
  toc: true
editor_options: 
  chunk_output_type: console
---

---
title:  "Trajectory (Trade-Seq) Seurat subset on ETV6 control D5 and D11"
---


```{r lib_loading, include=FALSE}
# Load packages, data and functions

library(sctransform)
library(reticulate)

# Load all necessary packages
library(Seurat)
library(htmlwidgets)
library(DT)
library(plotly)

library(pheatmap)
library(reshape2)
library("gridExtra")
library(knitr)
library(scater)

library(tradeSeq)
library(RColorBrewer)
library(SingleCellExperiment)
library(slingshot)
library(scales)
library(viridis)

library(dplyr)
library(rsample)
library(rminer)
library(parsnip)
library(ranger)
library(gam)
library(remotes)
```


```{r}
INPUT_PATH <- "<WORKING_DIR>/03_2020-42-set1et2/"
OUTPUT_PATH <- "<WORKING_DIR>/03_2020-42-set1et2/outputs/"
```


## Read RDS post analysis to modify some parameters
```{r}

ctrl_object <- readRDS(paste(INPUT_PATH, "ctrl_object.rds", sep="/"))

metadata <- as.data.frame(ctrl_object@meta.data)
metadata$UMAP_1 <- ctrl_object@reductions$umap@cell.embeddings[,1]
metadata$UMAP_2 <- ctrl_object@reductions$umap@cell.embeddings[,2]
metadata$tSNE_1 <- ctrl_object@reductions$tsne@cell.embeddings[,1]
metadata$tSNE_2 <- ctrl_object@reductions$tsne@cell.embeddings[,2]
metadata$PC1 <- ctrl_object@reductions[["pca"]]@cell.embeddings[,1]
metadata$PC2 <- ctrl_object@reductions[["pca"]]@cell.embeddings[,2]

metadata$cell_types <- as.factor(metadata$celltypes)
ctrl_object@meta.data[["celltypes"]]<- metadata$celltypes
Idents(ctrl_object) <- "celltypes"

sce_ctrl_object <- as.SingleCellExperiment(ctrl_object)
```

## Slingshot
```{r}
sce <- slingshot(sce_ctrl_object, 
                 clusterLabels = 'RNA_snn_res.1.2', 
                 reducedDim = 'UMAP', 
                 approx_points = F, 
                 extend = "n", 
                 reweight=T, 
                 reassign=T,
                 start.clus = 10)

summary(sce$slingPseudotime_1)
```


```{r}
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce$slingPseudotime_1, breaks=100)]

plot(reducedDims(sce)$UMAP, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce), lwd=2, col='black')
```

```{r}
plot(reducedDims(sce)$UMAP, col = brewer.pal(9,'Set1')[sce$GMM], pch=16, asp = 1)
lines(SlingshotDataSet(sce), lwd=2, type = 'lineages', col = 'black')
```

```{r}
sds <- slingshot(Embeddings(ctrl_object, "umap"), clusterLabels = ctrl_object$RNA_snn_res.1.2, 
                 start.clus = 10, stretch = 0)
```


```{r}
#' Assign a color to each cell based on some value
#' 
#' @param cell_vars Vector indicating the value of a variable associated with cells.
#' @param pal_fun Palette function that returns a vector of hex colors, whose
#' argument is the length of such a vector.
#' @param ... Extra arguments for pal_fun.
#' @return A vector of hex colors with one entry for each cell.
cell_pal <- function(cell_vars, pal_fun,...) {
  if (is.numeric(cell_vars)) {
    pal <- pal_fun(100, ...)
    return(pal[cut(cell_vars, breaks = 100)])
  } else {
    categories <- sort(unique(cell_vars))
    pal <- setNames(pal_fun(length(categories), ...), categories)
    return(pal[cell_vars])
  }
}
```


```{r}
cell_colors <- cell_pal(ctrl_object$celltypes, brewer_pal("qual", "Set2"))
cell_colors_clust <- cell_pal(ctrl_object$RNA_snn_res.1.2, hue_pal())
plot(reducedDims(sce)$UMAP, col = cell_colors, pch = 16, cex = 0.5)
lines(SlingshotDataSet(sce), lwd = 2, col = 'black')
# lines(sds@curves$Lineage1, lwd = 2, col = 'black')
# lines(sds@curves$Lineage2, lwd = 2, col = 'black')
# lines(sds@curves$Lineage3, lwd = 2, col = 'black')
# lines(sds@curves$Lineage4, lwd = 2, col = 'black')
# lines(sds@curves$Lineage5, lwd = 2, col = 'black')
title("Trajectory with Cell Type")

```

```{r}
nc <- 3
pt <- slingPseudotime(sce)
nms <- colnames(pt)
nr <- ceiling(length(nms)/nc)
pal <- viridis(100, end = 0.95)
par(mfrow = c(nr, nc))
for (i in nms) {
  colors <- pal[cut(pt[,i], breaks = 100)]
  plot(reducedDim(sce), col = colors, pch = 16, cex = 0.5, main = i)
}
```

## Converting to Slingshot dataset containing all the lineages
```{r}
sds <- SlingshotDataSet(ETV6_tradeSeq)
```

## Differential expression using Slingshot
```{r}
# Get top highly variable genes
top_hvg <- HVFInfo(ETV6_2020) %>% 
  mutate(., bc = rownames(.)) %>% 
  arrange(desc(variance)) %>% 
  top_n(1000, variance) %>% 
  pull(bc)
# Prepare data for random forest
dat_use <- t(GetAssayData(ETV6_2020, slot = "data")[top_hvg,])
dat_use_df <- cbind(slingPseudotime(sds)[,2], dat_use) # Do curve 2, so 2nd columnn
colnames(dat_use_df)[1] <- "pseudotime"
dat_use_df <- as.data.frame(dat_use_df[!is.na(dat_use_df[,1]),])
```

## Data randomly split into training and validation
```{r}
dat_split <- initial_split(dat_use_df)
dat_train <- training(dat_split)
dat_val <- testing(dat_split)
```

## Machine learning model, using random forest
```{r}
model <- rand_forest(mtry = 200, trees = 1400, min_n = 15, mode = "regression") %>%
  set_engine("ranger", importance = "impurity", num.threads = 3) %>%
  fit(pseudotime ~ ., data = dat_train)
```

## Validation set with 3 metrics
```{r}
val_results <- dat_val %>% 
  mutate(estimate = predict(model, .[,-1]) %>% pull()) %>% 
  select(truth = pseudotime, estimate)
mmetric(val_results$truth, val_results$estimate, metric = "ALL")
```

```{r}
summary(dat_use_df$pseudotime)
```

## TOP 10 var genes
```{r}
var_imp <- sort(model$fit$variable.importance, decreasing = TRUE)
top_genes <- names(var_imp)[1:20]
```

## Plot TOP 10 genes to predicting pseudotime
```{r}
# ,"Lineage2","Lineage3","Lineage4"
my_curves <- c("Lineage1")
for (i in seq_along(top_genes)) {
  for(y in my_curves){
    colors <- pal[cut(dat_use[,top_genes[i]], breaks = 100)]
    plot(reducedDim(sds), col = colors, 
        pch = 16, cex = 0.5, main = top_genes[i])
    lines(sds@curves[[y]], lwd = 3, col = 'red', type = 'lineages')
  }
}
```


## Differential Expression using Trade Seq
```{r}
set.seed(5)
setwd(OUTPUT_PATH)
# write.table(ctrl_object@assays$RNA@counts,"counts_FLI1_manip2_combined_filtered.txt",
# 	    sep="\t", quote=F, col.names=T, row.names=T)

counts <- ETV6_2020@assays$RNA@counts
counts_matrix <-  as.matrix(counts)

```

## Fit negative binomial model
```{r}
setwd(OUTPUT_PATH)
# icMat <- evaluateK(counts = counts_matrix, sds = sds, k = 3:6,
#                    nGenes = 100, verbose = T, plot = T, parallel = T)
# write.table(icMat,"nKnots_ETV6_Ctrl.txt",sep="\t", quote=F, col.names=T, row.names=T)
icMat <- read.table("nKnots_ETV6_Ctrl.txt", sep ="\t")
```

## Run fitGAM on top 1000 variable genes and a list of interest genes
```{r}
set.seed(7)
pseudotime <- slingPseudotime(sds, na = FALSE)
cellWeights <- slingCurveWeights(sds)
# pseudotime <- pseudotime[,-c(2,3,4,5)]
# cellWeights <- cellWeights[,-c(2,3,4,5)]
# 
# 
# cellWeights_matrix <- as.data.frame(as.matrix(cellWeights))
# colnames(cellWeights_matrix) <- "weight"
# pseudotime_matrix <-  as.data.frame(as.matrix(pseudotime))
# colnames(pseudotime_matrix) <- "pseudotime"
# merge_pseudotime_cellWeights <- merge(cellWeights_matrix, pseudotime_matrix, by = "row.names" )
# 
# merge_pseudotime_cellWeights$Keep <- ifelse(merge_pseudotime_cellWeights$weight != 0, "Yes", "No")
# mat <- merge_pseudotime_cellWeights[which(merge_pseudotime_cellWeights$Keep == "Yes"),1:3]
# rownames(mat) <- as.character(mat$Row.names)
# mat$Row.names <- NULL
# 
# 
# cellWeights_lineage1 <- as.numeric(mat$weight)
# names(cellWeights_lineage1) <- rownames(mat)
# pseudotime_lineage1 <- as.numeric(mat$pseudotime)
# names(pseudotime_lineage1) <- rownames(mat)
# 
# counts_matrix_lineage1 <- counts_matrix[,colnames(counts_matrix) %in% rownames(mat)]

# Parallelization parameters
BPPARAM <- BiocParallel::bpparam()
BPPARAM 

# Top variable genes and a list of interest
top_hvg_genes <- append(top_hvg, c("RUNX1","GATA1", "GATA2", "ETV6", "FLI1", "CEBPA", "FOG1", "TAL1", "NFE2", "CD34", "CD38", "HLA-DRA", "GP9", "ITGA2B", "DNM1L", "NDUFB9","ZFPM1"))
length(top_hvg_genes)

# Remove duplicated
top_hvg_genes_clean <- unique(top_hvg_genes)
length(top_hvg_genes_clean)

# All genes in the dataset
all_genes <- rownames(ETV6_2020@assays[["RNA"]]@data)

# Keep only gene present both in dataset and in the list
genes <- intersect(top_hvg_genes_clean, all_genes)

BPPARAM$workers <- 39
sce_fitGAM <- fitGAM(counts = counts_matrix, pseudotime = pseudotime, cellWeights = cellWeights,
                 nknots = 4, verbose = T, BPPARAM = BPPARAM, genes = genes)
# sce_fitGAM <- fitGAM(counts = counts_matrix_lineage1, pseudotime = pseudotime_lineage1, cellWeights = cellWeights_lineage1,
#                  nknots = 4, verbose = T, BPPARAM = BPPARAM, genes = genes)

```

## Check the number of genes which converge/fit the model 
```{r}
table(rowData(sce_fitGAM)$tradeSeq$converged)
```

## Within-lineage comparisons
## Association of gene expression with pseudotime
```{r}
assoRes <- associationTest(sce_fitGAM)
head(assoRes)
```
## Discovering progenitor marker genes
```{r}
# The function startVsEndTest uses a Wald test to assess the null hypothesis that the average expression at the starting point of the smoother (progenitor population) is equal to the average expression at the end point of the smoother (differentiated population). The test basically involves a comparison between two smoother coefficients for every lineage. The function startVsEndTest performs a global test across all lineages by default (i.e. it compares the start and end positions for all lineages simultaneously)

startRes <- startVsEndTest(sce_fitGAM)
```

## Visualization of the most significant gene in all lineage: Here: RPS4X
```{r}
oStart <- order(startRes$waldStat, decreasing = TRUE)
sigGeneStart <- names(sce_fitGAM)[oStart[3]]
plotSmoothers(sce_fitGAM, counts_matrix, gene = sigGeneStart)
```
## Visualisation in the UMAP of RPS4X gene expression
```{r}
plotGeneCount(sds, counts, gene = sigGeneStart)
```

## Comparing specific pseudotime values within a lineage
## we’d like to compare the expression for each gene at pseudotime values of 0.8 and 0.1.
```{r}
# The startVsEndTest compares two points on a lineage, and by default it is comparing the start point with the end point. However, this is a specific form of a more general capability of the startVsEndTest to compare any two points on any lineage. If the interest lies in comparing any two custom pseudotime values, one can specify this using the pseudotimeValues arguments in startVsEndTest.
customRes <- startVsEndTest(sce_fitGAM, pseudotimeValues = c(0.1, 0.8))
```

## Between-lineage comparisons
## Discovering differentiated cell type markers
```{r}
# comparing the average expression between end points of the lineage-specific smoothers
endRes <- diffEndTest(sce_fitGAM)
```

## Discover marker genes for the differentiated cell types 
```{r}
o <- order(endRes$waldStat, decreasing = TRUE)
sigGene <- names(sce_fitGAM)[o[1]]
plotSmoothers(sce_fitGAM, counts, sigGene)
```

## Plot the most significant gene using the plotSmoothers function: RPS8
```{r}
plotGeneCount(sds, counts, gene = sigGene)
```
